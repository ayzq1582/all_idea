### 1. 创建线程有哪些方式？
1. 继承Thread类创建线程
2. 通过Runable接口创建线程类
3. 通过Callable和Future创建线程
4. 通过线程池创建

### 2. 创建方式的差异是什么？
1. 采用Runable和Callable接口的方式创建多线程
`优势:`
> 1.线程类只是实现了Runable和Callable接口，还可以继承其他类。
> 2.在这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，行成清晰的模型，较好地体现了面向对象的思想。 

 `劣势:`
> 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。
2. 使用继承Thread类的方式创建多线程
`优势:`
> 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。	

 `劣势:`
> 线程类已经继承了Thread类，所以不能再继承其他父类。
3. Runnable和Callable的区别
> 1.Callable规定（重写）的方法是call(),Runbale规定（重写）的方法是run()。
> 2.Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。
> 3.Call方法可以抛出异常，run方法不可以。
> 4.运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果，通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

### 3. java线程的基本状态有什么？（5种）
1. **新建状态（New）:** 当线程对象创建后，即进入了新建状态，如：Thread t = new MyThread();
2. **就绪状态（Runnable）:** 当调用线程对象的start()方法（t.start();）,线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；
3. **运行状态（Running）:** 当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中。
4. **阻塞状态（Blocked）:** 处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。
> **1.等待阻塞：** 运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态。
> **2.同步阻塞：** 线程在获取synchronized同步锁失败（因为锁被其它线程所占用），它会进入同步阻塞状态。
> **3.其它阻塞：** 通过调用线程的sleep()或join()或发出了I/O请求是，线程会进入到阻塞状态。当sleep()状态超时，join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
5. **死亡状态（Dead）:** 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。